{
  "text": "Chapter 7: A Deep Dive into Keras - This chapter covers the spectrum of Keras workflows, from simple Sequential models to advanced custom training loops. It explores the principle of progressive disclosure of complexity, three ways to build models (Sequential, Functional API, and Model subclassing), custom training loops across different backends (TensorFlow, PyTorch, JAX), metrics, callbacks, and the relationship between training and inference modes.",
  "quiz": [
    {
      "question": "What principle guides the design of the Keras API?",
      "type": "choice",
      "options": [
        "Progressive disclosure of complexity",
        "Maximum performance optimization",
        "Strict functional programming",
        "Object-oriented encapsulation"
      ],
      "answer": "Progressive disclosure of complexity",
      "explanation": "Keras is designed to make simple use cases easy while allowing incremental learning for more complex scenarios."
    },
    {
      "question": "Which model-building API balances usability and flexibility best?",
      "type": "choice",
      "options": [
        "Functional API",
        "Sequential model",
        "Model subclassing",
        "Layer composition"
      ],
      "answer": "Functional API",
      "explanation": "The Functional API is the most commonly used because it offers a mid-point between usability and flexibility."
    },
    {
      "question": "What happens when you call a Sequential model before building it?",
      "type": "choice",
      "options": [
        "It has no weights",
        "It creates all weights",
        "It returns an error",
        "It generates random weights"
      ],
      "answer": "It has no weights",
      "explanation": "Layers only create weights when called for the first time or when build() is explicitly called."
    },
    {
      "question": "The Sequential model is limited to models with...",
      "type": "blank",
      "answer": "single input",
      "explanation": "Sequential models can only express models with a single input and a single output."
    },
    {
      "question": "What does the Input object represent in the Functional API?",
      "type": "choice",
      "options": [
        "A symbolic tensor",
        "Actual tensor data",
        "A validation placeholder",
        "The first layer output"
      ],
      "answer": "A symbolic tensor",
      "explanation": "Input objects are symbolic tensors that encode specifications without containing actual data."
    },
    {
      "question": "What main advantage does the Functional API provide over Sequential?",
      "type": "choice",
      "options": [
        "Multiple inputs and outputs",
        "Faster training speed overall",
        "Automatic hyperparameter tuning",
        "Built-in data augmentation"
      ],
      "answer": "Multiple inputs and outputs",
      "explanation": "The Functional API can express models with multiple inputs, outputs, and nonlinear topology."
    },
    {
      "question": "When training multi-output models, you pass data using lists or...",
      "type": "blank",
      "answer": "dictionaries",
      "explanation": "You can pass data using either ordered lists or dictionaries with named keys."
    },
    {
      "question": "Which utility visualizes the connectivity of a Functional model?",
      "type": "choice",
      "options": [
        "plot_model()",
        "visualize_model()",
        "show_architecture()",
        "display_graph()"
      ],
      "answer": "plot_model()",
      "explanation": "The plot_model() utility generates a graph visualization of layer connectivity."
    },
    {
      "question": "Where do you define layers in Model subclassing?",
      "type": "choice",
      "options": [
        "In __init__()",
        "In call() method",
        "In build() method",
        "In compile() method"
      ],
      "answer": "In __init__()",
      "explanation": "When subclassing Model, you define layers in __init__() and the forward pass in call()."
    },
    {
      "question": "The forward pass logic in a subclassed model is in the...",
      "type": "blank",
      "answer": "call",
      "explanation": "The call() method contains the forward pass logic for how data flows through layers."
    },
    {
      "question": "What is the main limitation of Model subclassing vs Functional API?",
      "type": "choice",
      "options": [
        "Cannot inspect connectivity",
        "Cannot use custom layers",
        "Slower training performance",
        "Requires more memory usage"
      ],
      "answer": "Cannot inspect connectivity",
      "explanation": "Subclassed models hide connectivity in call(), making the forward pass a black box."
    },
    {
      "question": "What key difference exists between Layer and Model subclasses?",
      "type": "choice",
      "options": [
        "Models have fit() and predict()",
        "Layers are always much faster",
        "Layers cannot be trained",
        "Models cannot be nested"
      ],
      "answer": "Models have fit() and predict()",
      "explanation": "A Model is the top-level object for training with fit(), while Layer is a building block."
    },
    {
      "question": "Can you use a subclassed model inside a Functional model?",
      "type": "choice",
      "options": [
        "Yes, they all interoperate",
        "No, they're incompatible",
        "Only after compilation",
        "Only for inference tasks"
      ],
      "answer": "Yes, they all interoperate",
      "explanation": "Sequential, Functional, and subclassed models can all interoperate smoothly."
    },
    {
      "question": "The compile() method specifies optimizer, loss function, and...",
      "type": "blank",
      "answer": "metrics",
      "explanation": "The compile() method configures the optimizer, loss function, and metrics to monitor."
    },
    {
      "question": "What are the two types of weights in layers and models?",
      "type": "choice",
      "options": [
        "Trainable and non-trainable",
        "Input and output weights",
        "Forward and backward weights",
        "Static and dynamic weights"
      ],
      "answer": "Trainable and non-trainable",
      "explanation": "Trainable weights update via backpropagation; non-trainable update during forward pass."
    },
    {
      "question": "Which built-in Keras layer uses non-trainable weights?",
      "type": "choice",
      "options": [
        "BatchNormalization",
        "Dense layer",
        "Dropout layer",
        "Flatten layer"
      ],
      "answer": "BatchNormalization",
      "explanation": "BatchNormalization uses non-trainable weights to track running statistics."
    },
    {
      "question": "Layers like Dropout have different training vs inference behavior controlled by...",
      "type": "blank",
      "answer": "training",
      "explanation": "The training Boolean argument determines whether a layer operates in training or inference mode."
    },
    {
      "question": "What method updates the state of a custom metric?",
      "type": "choice",
      "options": [
        "update_state()",
        "compute_state()",
        "refresh_state()",
        "modify_state()"
      ],
      "answer": "update_state()",
      "explanation": "The update_state() method implements the logic for updating a metric's internal state."
    },
    {
      "question": "Which method returns the current value of a metric?",
      "type": "choice",
      "options": [
        "result()",
        "get_value()",
        "compute()",
        "output()"
      ],
      "answer": "result()",
      "explanation": "The result() method returns the current computed value of the metric."
    },
    {
      "question": "To reuse metrics across epochs, you must implement the...",
      "type": "blank",
      "answer": "reset_state",
      "explanation": "The reset_state() method clears the metric's state for reuse across epochs."
    },
    {
      "question": "What is the primary purpose of Keras callbacks?",
      "type": "choice",
      "options": [
        "Dynamic actions during training",
        "Preprocess data before training",
        "Compile model automatically",
        "Generate synthetic data"
      ],
      "answer": "Dynamic actions during training",
      "explanation": "Callbacks enable actions at various points during training based on model state."
    },
    {
      "question": "EarlyStopping stops training when a monitored metric...",
      "type": "choice",
      "options": [
        "Stops improving",
        "Reaches a threshold",
        "Becomes negative",
        "Exceeds validation"
      ],
      "answer": "Stops improving",
      "explanation": "EarlyStopping interrupts training when a metric hasn't improved for a set number of epochs."
    },
    {
      "question": "The ModelCheckpoint callback is typically used to...",
      "type": "blank",
      "answer": "save",
      "explanation": "ModelCheckpoint saves model weights at intervals, optionally keeping only the best version."
    },
    {
      "question": "Which method is called at the start of every epoch in custom callbacks?",
      "type": "choice",
      "options": [
        "on_epoch_begin()",
        "on_epoch_start()",
        "epoch_initialize()",
        "begin_epoch()"
      ],
      "answer": "on_epoch_begin()",
      "explanation": "Custom callbacks override on_epoch_begin() to execute code at each epoch's start."
    },
    {
      "question": "Which tool provides browser-based monitoring during training?",
      "type": "choice",
      "options": [
        "TensorBoard",
        "KerasBoard",
        "ModelMonitor",
        "TrainingVisualizer"
      ],
      "answer": "TensorBoard",
      "explanation": "TensorBoard is a browser application that monitors metrics and visualizes architecture."
    },
    {
      "question": "The TensorBoard callback requires you to specify a...",
      "type": "blank",
      "answer": "log_dir",
      "explanation": "TensorBoard needs a log directory path where it writes monitoring logs."
    },
    {
      "question": "In TensorFlow, gradients are computed within a...",
      "type": "blank",
      "answer": "GradientTape",
      "explanation": "TensorFlow uses a GradientTape context to record operations for differentiation."
    },
    {
      "question": "What PyTorch method builds the graph and populates gradients?",
      "type": "choice",
      "options": [
        "backward()",
        "compute_gradients()",
        "gradient_descent()",
        "backpropagate()"
      ],
      "answer": "backward()",
      "explanation": "Calling backward() on a loss tensor computes and populates parameter gradients."
    },
    {
      "question": "Why must you call zero_grad() in PyTorch before each step?",
      "type": "choice",
      "options": [
        "Gradients accumulate",
        "Initialize weights",
        "Reset learning rate",
        "Clear data cache"
      ],
      "answer": "Gradients accumulate",
      "explanation": "Calls to backward() are additive, so gradients must be cleared to avoid accumulation."
    },
    {
      "question": "In JAX, the stateless forward pass method is called...",
      "type": "blank",
      "answer": "stateless_call",
      "explanation": "JAX uses stateless_call() which takes weights as input and returns updated non-trainable weights."
    },
    {
      "question": "What makes JAX different from TensorFlow and PyTorch?",
      "type": "choice",
      "options": [
        "Fully stateless paradigm",
        "Object-oriented only",
        "Cannot be compiled",
        "Only eager execution"
      ],
      "answer": "Fully stateless paradigm",
      "explanation": "JAX's statelessness requires explicit state management, enabling better optimization."
    },
    {
      "question": "What argument tells jax.value_and_grad() about auxiliary outputs?",
      "type": "choice",
      "options": [
        "has_aux=True",
        "return_aux=True",
        "include_extra=True",
        "multiple_returns=True"
      ],
      "answer": "has_aux=True",
      "explanation": "The has_aux argument indicates the function returns auxiliary values beyond the scalar loss."
    },
    {
      "question": "In JAX, the optimizer's stateless update method is called...",
      "type": "blank",
      "answer": "stateless_apply",
      "explanation": "The stateless_apply() method updates variables and optimizer state without in-place modification."
    },
    {
      "question": "When should you pass training=True to a model's call method?",
      "type": "choice",
      "options": [
        "During forward pass in training",
        "Only during first epoch",
        "Only with Dropout layers",
        "During evaluation testing"
      ],
      "answer": "During forward pass in training",
      "explanation": "The training argument ensures layers like Dropout operate correctly during training."
    },
    {
      "question": "The keras.metrics.Mean class is useful for tracking the...",
      "type": "blank",
      "answer": "average",
      "explanation": "Mean tracks the running average of scalar values like loss across batches."
    },
    {
      "question": "How can you customize fit() while using the framework's loop?",
      "type": "choice",
      "options": [
        "Override train_step()",
        "Override compile()",
        "Override __call__()",
        "Override forward()"
      ],
      "answer": "Override train_step()",
      "explanation": "Overriding train_step() lets you customize training logic while keeping fit()'s features."
    },
    {
      "question": "What should the train_step() method return?",
      "type": "choice",
      "options": [
        "Dictionary of metrics",
        "Updated model weights",
        "Loss value only",
        "Inputs and targets"
      ],
      "answer": "Dictionary of metrics",
      "explanation": "train_step() returns a dictionary mapping metric names to their current values."
    },
    {
      "question": "To auto-reset metrics each epoch, list them in the model's...",
      "type": "blank",
      "answer": "metrics",
      "explanation": "Listing metrics in model.metrics enables automatic reset_state() calls."
    },
    {
      "question": "What is the main advantage of model subclassing?",
      "type": "choice",
      "options": [
        "Maximum flexibility",
        "Faster execution",
        "Automatic optimization",
        "Built-in regularization"
      ],
      "answer": "Maximum flexibility",
      "explanation": "Subclassing provides complete control, allowing dynamic graphs with loops and conditionals."
    },
    {
      "question": "Why use model.trainable_weights instead of model.weights?",
      "type": "choice",
      "options": [
        "Excludes non-trainable weights",
        "Improves training speed",
        "Alphabetical ordering",
        "Avoids memory leaks"
      ],
      "answer": "Excludes non-trainable weights",
      "explanation": "trainable_weights excludes weights that layers update during forward pass."
    },
    {
      "question": "The self.compute_loss() method combines loss function with...",
      "type": "blank",
      "answer": "regularization",
      "explanation": "compute_loss() combines the compiled loss with any layer regularization losses."
    },
    {
      "question": "What is the main tradeoff of using Model subclassing?",
      "type": "choice",
      "options": [
        "Flexibility vs error surface",
        "Speed vs memory usage",
        "Performance vs compatibility",
        "Debugging vs architecture"
      ],
      "answer": "Flexibility vs error surface",
      "explanation": "Subclassing gives flexibility but increases error surface and reduces built-in features."
    },
    {
      "question": "The Functional API treats the model as a...",
      "type": "blank",
      "answer": "graph",
      "explanation": "Functional models are explicit directed acyclic graphs of layers that can be inspected."
    },
    {
      "question": "Which workflow is recommended for most use cases?",
      "type": "choice",
      "options": [
        "Functional API with subclassed layers",
        "Sequential models only",
        "Pure model subclassing",
        "Custom training loops"
      ],
      "answer": "Functional API with subclassed layers",
      "explanation": "This combination provides the best balance of flexibility and Functional API advantages."
    },
    {
      "question": "To build Sequential models incrementally, you use the...",
      "type": "blank",
      "answer": "add",
      "explanation": "The add() method allows incrementally building Sequential models like Python lists."
    },
    {
      "question": "Which method displays a text summary of model architecture?",
      "type": "choice",
      "options": [
        "summary()",
        "describe()",
        "info()",
        "architecture()"
      ],
      "answer": "summary()",
      "explanation": "The summary() method displays layers, output shapes, and parameter counts."
    },
    {
      "question": "Calling a layer on a symbolic tensor returns...",
      "type": "choice",
      "options": [
        "New symbolic tensor",
        "Actual computed values",
        "An error message",
        "The layer's weights"
      ],
      "answer": "New symbolic tensor",
      "explanation": "Calling layers on symbolic tensors returns new symbolic tensors with updated shape info."
    },
    {
      "question": "In supervised learning, targets are also called labels or...",
      "type": "blank",
      "answer": "annotations",
      "explanation": "The ground truth values are referred to as targets, labels, or annotations."
    },
    {
      "question": "What does the fit() method do during training?",
      "type": "choice",
      "options": [
        "Runs complete training loop",
        "Only computes forward passes",
        "Only evaluates metrics",
        "Generates synthetic data"
      ],
      "answer": "Runs complete training loop",
      "explanation": "The fit() method orchestrates forward pass, loss, gradients, and weight updates."
    },
    {
      "question": "The validation_data parameter in fit() is used to...",
      "type": "choice",
      "options": [
        "Monitor unseen data performance",
        "Augment training data",
        "Replace training data",
        "Initialize model weights"
      ],
      "answer": "Monitor unseen data performance",
      "explanation": "validation_data provides a separate dataset to evaluate generalization during training."
    }
  ]
}
